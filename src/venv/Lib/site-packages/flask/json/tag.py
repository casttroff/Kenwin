<<<<<<< HEAD
=======
# -*- coding: utf-8 -*-
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b
"""
Tagged JSON
~~~~~~~~~~~

<<<<<<< HEAD
A compact representation for lossless serialization of non-standard JSON
types. :class:`~flask.sessions.SecureCookieSessionInterface` uses this
to serialize the session data, but it may be useful in other places. It
can be extended to support other types.
=======
A compact representation for lossless serialization of non-standard JSON types.
:class:`~flask.sessions.SecureCookieSessionInterface` uses this to serialize
the session data, but it may be useful in other places. It can be extended to
support other types.
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b

.. autoclass:: TaggedJSONSerializer
    :members:

.. autoclass:: JSONTag
    :members:

<<<<<<< HEAD
Let's see an example that adds support for
:class:`~collections.OrderedDict`. Dicts don't have an order in JSON, so
to handle this we will dump the items as a list of ``[key, value]``
pairs. Subclass :class:`JSONTag` and give it the new key ``' od'`` to
identify the type. The session serializer processes dicts first, so
insert the new tag at the front of the order since ``OrderedDict`` must
be processed before ``dict``.

.. code-block:: python
=======
Let's seen an example that adds support for :class:`~collections.OrderedDict`.
Dicts don't have an order in Python or JSON, so to handle this we will dump
the items as a list of ``[key, value]`` pairs. Subclass :class:`JSONTag` and
give it the new key ``' od'`` to identify the type. The session serializer
processes dicts first, so insert the new tag at the front of the order since
``OrderedDict`` must be processed before ``dict``. ::
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b

    from flask.json.tag import JSONTag

    class TagOrderedDict(JSONTag):
        __slots__ = ('serializer',)
        key = ' od'

        def check(self, value):
            return isinstance(value, OrderedDict)

        def to_json(self, value):
            return [[k, self.serializer.tag(v)] for k, v in iteritems(value)]

        def to_python(self, value):
            return OrderedDict(value)

    app.session_interface.serializer.register(TagOrderedDict, index=0)
<<<<<<< HEAD
"""
import typing as t
=======

:copyright: 2010 Pallets
:license: BSD-3-Clause
"""
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b
from base64 import b64decode
from base64 import b64encode
from datetime import datetime
from uuid import UUID

<<<<<<< HEAD
from markupsafe import Markup
from werkzeug.http import http_date
from werkzeug.http import parse_date

=======
from jinja2 import Markup
from werkzeug.http import http_date
from werkzeug.http import parse_date

from .._compat import iteritems
from .._compat import text_type
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b
from ..json import dumps
from ..json import loads


<<<<<<< HEAD
class JSONTag:
=======
class JSONTag(object):
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b
    """Base class for defining type tags for :class:`TaggedJSONSerializer`."""

    __slots__ = ("serializer",)

    #: The tag to mark the serialized object with. If ``None``, this tag is
    #: only used as an intermediate step during tagging.
<<<<<<< HEAD
    key: t.Optional[str] = None

    def __init__(self, serializer: "TaggedJSONSerializer") -> None:
        """Create a tagger for the given serializer."""
        self.serializer = serializer

    def check(self, value: t.Any) -> bool:
        """Check if the given value should be tagged by this tag."""
        raise NotImplementedError

    def to_json(self, value: t.Any) -> t.Any:
=======
    key = None

    def __init__(self, serializer):
        """Create a tagger for the given serializer."""
        self.serializer = serializer

    def check(self, value):
        """Check if the given value should be tagged by this tag."""
        raise NotImplementedError

    def to_json(self, value):
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b
        """Convert the Python object to an object that is a valid JSON type.
        The tag will be added later."""
        raise NotImplementedError

<<<<<<< HEAD
    def to_python(self, value: t.Any) -> t.Any:
=======
    def to_python(self, value):
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b
        """Convert the JSON representation back to the correct type. The tag
        will already be removed."""
        raise NotImplementedError

<<<<<<< HEAD
    def tag(self, value: t.Any) -> t.Any:
=======
    def tag(self, value):
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b
        """Convert the value to a valid JSON type and add the tag structure
        around it."""
        return {self.key: self.to_json(value)}


class TagDict(JSONTag):
    """Tag for 1-item dicts whose only key matches a registered tag.

    Internally, the dict key is suffixed with `__`, and the suffix is removed
    when deserializing.
    """

    __slots__ = ()
    key = " di"

<<<<<<< HEAD
    def check(self, value: t.Any) -> bool:
=======
    def check(self, value):
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b
        return (
            isinstance(value, dict)
            and len(value) == 1
            and next(iter(value)) in self.serializer.tags
        )

<<<<<<< HEAD
    def to_json(self, value: t.Any) -> t.Any:
        key = next(iter(value))
        return {f"{key}__": self.serializer.tag(value[key])}

    def to_python(self, value: t.Any) -> t.Any:
=======
    def to_json(self, value):
        key = next(iter(value))
        return {key + "__": self.serializer.tag(value[key])}

    def to_python(self, value):
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b
        key = next(iter(value))
        return {key[:-2]: value[key]}


class PassDict(JSONTag):
    __slots__ = ()

<<<<<<< HEAD
    def check(self, value: t.Any) -> bool:
        return isinstance(value, dict)

    def to_json(self, value: t.Any) -> t.Any:
        # JSON objects may only have string keys, so don't bother tagging the
        # key here.
        return {k: self.serializer.tag(v) for k, v in value.items()}
=======
    def check(self, value):
        return isinstance(value, dict)

    def to_json(self, value):
        # JSON objects may only have string keys, so don't bother tagging the
        # key here.
        return dict((k, self.serializer.tag(v)) for k, v in iteritems(value))
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b

    tag = to_json


class TagTuple(JSONTag):
    __slots__ = ()
    key = " t"

<<<<<<< HEAD
    def check(self, value: t.Any) -> bool:
        return isinstance(value, tuple)

    def to_json(self, value: t.Any) -> t.Any:
        return [self.serializer.tag(item) for item in value]

    def to_python(self, value: t.Any) -> t.Any:
=======
    def check(self, value):
        return isinstance(value, tuple)

    def to_json(self, value):
        return [self.serializer.tag(item) for item in value]

    def to_python(self, value):
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b
        return tuple(value)


class PassList(JSONTag):
    __slots__ = ()

<<<<<<< HEAD
    def check(self, value: t.Any) -> bool:
        return isinstance(value, list)

    def to_json(self, value: t.Any) -> t.Any:
=======
    def check(self, value):
        return isinstance(value, list)

    def to_json(self, value):
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b
        return [self.serializer.tag(item) for item in value]

    tag = to_json


class TagBytes(JSONTag):
    __slots__ = ()
    key = " b"

<<<<<<< HEAD
    def check(self, value: t.Any) -> bool:
        return isinstance(value, bytes)

    def to_json(self, value: t.Any) -> t.Any:
        return b64encode(value).decode("ascii")

    def to_python(self, value: t.Any) -> t.Any:
=======
    def check(self, value):
        return isinstance(value, bytes)

    def to_json(self, value):
        return b64encode(value).decode("ascii")

    def to_python(self, value):
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b
        return b64decode(value)


class TagMarkup(JSONTag):
<<<<<<< HEAD
    """Serialize anything matching the :class:`~markupsafe.Markup` API by
    having a ``__html__`` method to the result of that method. Always
    deserializes to an instance of :class:`~markupsafe.Markup`."""
=======
    """Serialize anything matching the :class:`~flask.Markup` API by
    having a ``__html__`` method to the result of that method. Always
    deserializes to an instance of :class:`~flask.Markup`."""
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b

    __slots__ = ()
    key = " m"

<<<<<<< HEAD
    def check(self, value: t.Any) -> bool:
        return callable(getattr(value, "__html__", None))

    def to_json(self, value: t.Any) -> t.Any:
        return str(value.__html__())

    def to_python(self, value: t.Any) -> t.Any:
=======
    def check(self, value):
        return callable(getattr(value, "__html__", None))

    def to_json(self, value):
        return text_type(value.__html__())

    def to_python(self, value):
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b
        return Markup(value)


class TagUUID(JSONTag):
    __slots__ = ()
    key = " u"

<<<<<<< HEAD
    def check(self, value: t.Any) -> bool:
        return isinstance(value, UUID)

    def to_json(self, value: t.Any) -> t.Any:
        return value.hex

    def to_python(self, value: t.Any) -> t.Any:
=======
    def check(self, value):
        return isinstance(value, UUID)

    def to_json(self, value):
        return value.hex

    def to_python(self, value):
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b
        return UUID(value)


class TagDateTime(JSONTag):
    __slots__ = ()
    key = " d"

<<<<<<< HEAD
    def check(self, value: t.Any) -> bool:
        return isinstance(value, datetime)

    def to_json(self, value: t.Any) -> t.Any:
        return http_date(value)

    def to_python(self, value: t.Any) -> t.Any:
        return parse_date(value)


class TaggedJSONSerializer:
=======
    def check(self, value):
        return isinstance(value, datetime)

    def to_json(self, value):
        return http_date(value)

    def to_python(self, value):
        return parse_date(value)


class TaggedJSONSerializer(object):
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b
    """Serializer that uses a tag system to compactly represent objects that
    are not JSON types. Passed as the intermediate serializer to
    :class:`itsdangerous.Serializer`.

    The following extra types are supported:

    * :class:`dict`
    * :class:`tuple`
    * :class:`bytes`
<<<<<<< HEAD
    * :class:`~markupsafe.Markup`
=======
    * :class:`~flask.Markup`
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b
    * :class:`~uuid.UUID`
    * :class:`~datetime.datetime`
    """

    __slots__ = ("tags", "order")

    #: Tag classes to bind when creating the serializer. Other tags can be
    #: added later using :meth:`~register`.
    default_tags = [
        TagDict,
        PassDict,
        TagTuple,
        PassList,
        TagBytes,
        TagMarkup,
        TagUUID,
        TagDateTime,
    ]

<<<<<<< HEAD
    def __init__(self) -> None:
        self.tags: t.Dict[str, JSONTag] = {}
        self.order: t.List[JSONTag] = []
=======
    def __init__(self):
        self.tags = {}
        self.order = []
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b

        for cls in self.default_tags:
            self.register(cls)

<<<<<<< HEAD
    def register(
        self,
        tag_class: t.Type[JSONTag],
        force: bool = False,
        index: t.Optional[int] = None,
    ) -> None:
=======
    def register(self, tag_class, force=False, index=None):
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b
        """Register a new tag with this serializer.

        :param tag_class: tag class to register. Will be instantiated with this
            serializer instance.
        :param force: overwrite an existing tag. If false (default), a
            :exc:`KeyError` is raised.
        :param index: index to insert the new tag in the tag order. Useful when
            the new tag is a special case of an existing tag. If ``None``
            (default), the tag is appended to the end of the order.

        :raise KeyError: if the tag key is already registered and ``force`` is
            not true.
        """
        tag = tag_class(self)
        key = tag.key

        if key is not None:
            if not force and key in self.tags:
<<<<<<< HEAD
                raise KeyError(f"Tag '{key}' is already registered.")
=======
                raise KeyError("Tag '{0}' is already registered.".format(key))
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b

            self.tags[key] = tag

        if index is None:
            self.order.append(tag)
        else:
            self.order.insert(index, tag)

<<<<<<< HEAD
    def tag(self, value: t.Any) -> t.Dict[str, t.Any]:
=======
    def tag(self, value):
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b
        """Convert a value to a tagged representation if necessary."""
        for tag in self.order:
            if tag.check(value):
                return tag.tag(value)

        return value

<<<<<<< HEAD
    def untag(self, value: t.Dict[str, t.Any]) -> t.Any:
=======
    def untag(self, value):
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b
        """Convert a tagged representation back to the original type."""
        if len(value) != 1:
            return value

        key = next(iter(value))

        if key not in self.tags:
            return value

        return self.tags[key].to_python(value[key])

<<<<<<< HEAD
    def dumps(self, value: t.Any) -> str:
        """Tag the value and dump it to a compact JSON string."""
        return dumps(self.tag(value), separators=(",", ":"))

    def loads(self, value: str) -> t.Any:
=======
    def dumps(self, value):
        """Tag the value and dump it to a compact JSON string."""
        return dumps(self.tag(value), separators=(",", ":"))

    def loads(self, value):
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b
        """Load data from a JSON string and deserialized any tagged objects."""
        return loads(value, object_hook=self.untag)
