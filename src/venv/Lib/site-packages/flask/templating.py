<<<<<<< HEAD
import typing as t

from jinja2 import BaseLoader
from jinja2 import Environment as BaseEnvironment
from jinja2 import Template
=======
# -*- coding: utf-8 -*-
"""
    flask.templating
    ~~~~~~~~~~~~~~~~

    Implements the bridge to Jinja2.

    :copyright: 2010 Pallets
    :license: BSD-3-Clause
"""
from jinja2 import BaseLoader
from jinja2 import Environment as BaseEnvironment
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b
from jinja2 import TemplateNotFound

from .globals import _app_ctx_stack
from .globals import _request_ctx_stack
from .signals import before_render_template
from .signals import template_rendered

<<<<<<< HEAD
if t.TYPE_CHECKING:
    from .app import Flask
    from .scaffold import Scaffold


def _default_template_ctx_processor() -> t.Dict[str, t.Any]:
=======

def _default_template_ctx_processor():
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b
    """Default template context processor.  Injects `request`,
    `session` and `g`.
    """
    reqctx = _request_ctx_stack.top
    appctx = _app_ctx_stack.top
    rv = {}
    if appctx is not None:
        rv["g"] = appctx.g
    if reqctx is not None:
        rv["request"] = reqctx.request
        rv["session"] = reqctx.session
    return rv


class Environment(BaseEnvironment):
    """Works like a regular Jinja2 environment but has some additional
    knowledge of how Flask's blueprint works so that it can prepend the
    name of the blueprint to referenced templates if necessary.
    """

<<<<<<< HEAD
    def __init__(self, app: "Flask", **options: t.Any) -> None:
=======
    def __init__(self, app, **options):
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b
        if "loader" not in options:
            options["loader"] = app.create_global_jinja_loader()
        BaseEnvironment.__init__(self, **options)
        self.app = app


class DispatchingJinjaLoader(BaseLoader):
    """A loader that looks for templates in the application and all
    the blueprint folders.
    """

<<<<<<< HEAD
    def __init__(self, app: "Flask") -> None:
        self.app = app

    def get_source(  # type: ignore
        self, environment: Environment, template: str
    ) -> t.Tuple[str, t.Optional[str], t.Optional[t.Callable]]:
=======
    def __init__(self, app):
        self.app = app

    def get_source(self, environment, template):
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b
        if self.app.config["EXPLAIN_TEMPLATE_LOADING"]:
            return self._get_source_explained(environment, template)
        return self._get_source_fast(environment, template)

<<<<<<< HEAD
    def _get_source_explained(
        self, environment: Environment, template: str
    ) -> t.Tuple[str, t.Optional[str], t.Optional[t.Callable]]:
        attempts = []
        rv: t.Optional[t.Tuple[str, t.Optional[str], t.Optional[t.Callable[[], bool]]]]
        trv: t.Optional[
            t.Tuple[str, t.Optional[str], t.Optional[t.Callable[[], bool]]]
        ] = None
=======
    def _get_source_explained(self, environment, template):
        attempts = []
        trv = None
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b

        for srcobj, loader in self._iter_loaders(template):
            try:
                rv = loader.get_source(environment, template)
                if trv is None:
                    trv = rv
            except TemplateNotFound:
                rv = None
            attempts.append((loader, srcobj, rv))

        from .debughelpers import explain_template_loading_attempts

        explain_template_loading_attempts(self.app, template, attempts)

        if trv is not None:
            return trv
        raise TemplateNotFound(template)

<<<<<<< HEAD
    def _get_source_fast(
        self, environment: Environment, template: str
    ) -> t.Tuple[str, t.Optional[str], t.Optional[t.Callable]]:
=======
    def _get_source_fast(self, environment, template):
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b
        for _srcobj, loader in self._iter_loaders(template):
            try:
                return loader.get_source(environment, template)
            except TemplateNotFound:
                continue
        raise TemplateNotFound(template)

<<<<<<< HEAD
    def _iter_loaders(
        self, template: str
    ) -> t.Generator[t.Tuple["Scaffold", BaseLoader], None, None]:
=======
    def _iter_loaders(self, template):
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b
        loader = self.app.jinja_loader
        if loader is not None:
            yield self.app, loader

        for blueprint in self.app.iter_blueprints():
            loader = blueprint.jinja_loader
            if loader is not None:
                yield blueprint, loader

<<<<<<< HEAD
    def list_templates(self) -> t.List[str]:
=======
    def list_templates(self):
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b
        result = set()
        loader = self.app.jinja_loader
        if loader is not None:
            result.update(loader.list_templates())

        for blueprint in self.app.iter_blueprints():
            loader = blueprint.jinja_loader
            if loader is not None:
                for template in loader.list_templates():
                    result.add(template)

        return list(result)


<<<<<<< HEAD
def _render(template: Template, context: dict, app: "Flask") -> str:
=======
def _render(template, context, app):
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b
    """Renders the template and fires the signal"""

    before_render_template.send(app, template=template, context=context)
    rv = template.render(context)
    template_rendered.send(app, template=template, context=context)
    return rv


<<<<<<< HEAD
def render_template(
    template_name_or_list: t.Union[str, Template, t.List[t.Union[str, Template]]],
    **context: t.Any
) -> str:
=======
def render_template(template_name_or_list, **context):
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b
    """Renders a template from the template folder with the given
    context.

    :param template_name_or_list: the name of the template to be
                                  rendered, or an iterable with template names
                                  the first one existing will be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """
    ctx = _app_ctx_stack.top
    ctx.app.update_template_context(context)
    return _render(
        ctx.app.jinja_env.get_or_select_template(template_name_or_list),
        context,
        ctx.app,
    )


<<<<<<< HEAD
def render_template_string(source: str, **context: t.Any) -> str:
=======
def render_template_string(source, **context):
>>>>>>> 8ea21d60320e8cc8ae7d381c28e4c334b8d95b8b
    """Renders a template from the given template source string
    with the given context. Template variables will be autoescaped.

    :param source: the source code of the template to be
                   rendered
    :param context: the variables that should be available in the
                    context of the template.
    """
    ctx = _app_ctx_stack.top
    ctx.app.update_template_context(context)
    return _render(ctx.app.jinja_env.from_string(source), context, ctx.app)
